% Romain Jacob
% April 14, 2016
%
% Initilize the time simulation of the Bolt-embeddedWireless Sensor
% Network. It set up the network parameters, the flow set, and the 
% necessary data structure.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% 
% N_slots give the number of slots in one LWB round given the packet size
% (16, 32, 64 or 128 bytes) and the hop count of the network (1 to 10)
% It is returned by the lwb_limits function (see the lwb parameters within)

N_slots = lwb_limits();
packet_size_id = 2;
% 1 : 16  bytes
% 2 : 32  bytes
% 3 : 64  bytes
% 4 : 128 bytes
hop_count = 6;
packet_per_round = N_slots(packet_size_id,hop_count);
%% Definition of the parameters

N = 20;                 %Number of nodes in the network     [.] 
Bolt_clock_freq = 8e6;  %Frequency of the Bolt processor    [Hz]

S_CP_mem    = 2.052e6;  %Available momory in CP             [Bytes]
%In practice, we do not have the external memomy on the nodes, hence the
%very limited data storage
% S_CP_mem    = 4e3;      %Available momory in CP             [Bytes]
S_BOLT_mem  = 1.89e4;   %Available memory in a Bolt queue   [Bytes]

packet_size = 2^(3+packet_size_id);
                        %Packet size                        [Bytes]
S_CP_pack   = floor(S_CP_mem/packet_size);     %# of packet storable in CP     [#packets]
S_BOLT_pack = floor(S_BOLT_mem/packet_size);   %# of packet storable in BOLT   [#packets]

% Following values come from the Bolt paper analysis
C_w_max = 1.16e-4;       %WCET for a write operation         [s]
C_w_min = 1.16e-4;       %WCET for a write operation         [s]
C_r_max = 1.12e-4;       %WCET for a read operatiion         [s]
C_r_min = 1.12e-4;       %BCET for a read operatiion         [s]
C_f_max = C_r_max*S_BOLT_pack;
                        %WCET for a flush operation         [s]
% Others hardware-dependant constants        
C_CP_test_in = 0;    %WCET for the admission test of all incoming packets [s]
C_CP_test_out = 0;   %WCET for the admission test of all outgoing packets [s]

C_lwb = 1;              %Fixed length of a LWB round        [s]
util_max = 1;         %Maximal utilization allowed of the bandwidth of LWB    [.]
r = 0.5;                %Deadline ratio                     [.]

C_CP_full   = C_lwb + C_f_max + packet_per_round*C_w_max + C_CP_test_in + C_CP_test_out;
                        %Worst-case execution time of a full CP job     [s]
                        
delta_const = (packet_per_round + 1) * C_w_max ...
                + 2 * C_f_max + C_CP_full;        %Constant delay on transmission [s]
delta_f = C_w_max + C_f_max + C_CP_full;        %Constant delay on transmission [s]
delta_g = (packet_per_round) * C_w_max ...
            + (packet_per_round - 1) * C_r_max ...
            + C_f_max ;        %Constant delay on transmission [s]
         
            
            
T_flush_receive_min = 0.01*ones(1,N);
                                        
param = struct(...
    'N', N ,...
    'packet_size', packet_size,... 
    'C_w_max', C_w_max ,... 
    'C_w_min', C_w_min ,... 
    'C_r_min', C_r_min ,... 
    'C_r_max', C_r_max ,... 
    'C_f_max', C_f_max ,... 
    'C_lwb', C_lwb ,... 
    'packet_per_round', packet_per_round ,...
    'util_max', util_max ,... 
    'r', r ,...
    'C_CP_full', C_CP_full ,...
    'S_CP_pack', S_CP_pack ,... 
    'S_BOLT_pack', S_BOLT_pack ,... 
    'delta_const', delta_const,...
    'delta_f', delta_f,...
    'delta_g', delta_g,...
    'timeStep', timeStep,...
    'horizon', horizon);

if 0
    fprintf('r: %f\n\n'     ,param.r)
end
                                        

%% Definition of the network
% We assume a network of N nodes, with IDs from 1 to N. 
% Node 1 plays the roles of 
% - Sink, connected to the base station and 
% - Host, running the Blink scheduler for LWB
%
% The network is initialized with registration flows between every node
% and the Sink, in both directions. 
% NO NODE-TO-NODE FLOW IS ALLOWED!
% Note that flows are unidirectionnal.

nodeData = [];

boltQueueStruct = struct(...
    'queue'     , zeros(1, S_BOLT_pack), ...
    'next_in'   , 1, ...
    'next_out'  , 1, ...
    'IND'       , false, ...
    'current_buffer', 0, ...
    'max_buffer', 0 ...
    );    
CPMemoryStruct = struct(...
    'queue_in'      , zeros(1, packet_per_round), ...
    'next_in'       , 1, ...
    'next_out'      , 1, ...
    'IND'           , false, ...
    'counter_out'   , 0, ...
    'current_buffer', 0, ...
    'max_buffer', 0 ...
    );    

%Define the data structure for one node
nodeDataStruct = struct(...
    'sourceStream'  , [] ,...
    'destStream'    , [] ,...
    'T_flush_send', param.C_CP_full ,...
    'T_flush_receive', inf ,...
    'util_AP_max'   , 0.5 ,...
    'util_BOLT_IN'  , 0 ,...
    'util_BOLT_OUT' , 0 ,...
    'util_CP'       , 0 ,...
    'util_LWB'      , 0, ...   
    'CPFlushCount'  , 0, ...
    'CPReadCount'   , 0, ...
    'CPWriteCount'   , 0, ...
    'APFlushCount'  , 0, ...    
    'APReadCount'   , 0, ...   
    'AP_flush_in_progress'   , false, ... 
    'CP_flush_in_progress'   , false, ...   
    'BOLT_IN'       , boltQueueStruct, ...   
    'BOLT_OUT'      , boltQueueStruct, ...   
    'CP_MEM'        , CPMemoryStruct );

for node = 1:N
    nodeData = [nodeData nodeDataStruct];    
end

%% Definition of the flow set
flowSetDefinition

%% Schedule of rounds
% To start with, only implement the simple greedy schedule. I will think
% about optimizing later (maybe...)

roundPeriod = param.C_CP_full;
% schedule = scheduler_contiguous(flows, roundPeriod, param, 0);
schedule = scheduler_lazy(flows, roundPeriod, param, 1);

%% Definition of the time matrices
mode = 'max';
% 'max'  : randomized initial offset then periodic release
% 'rand' : randomized initial offset then periodic plus random offset

flowTime = {};
% Define the start of writing time for all flows
% The generataion of the end time of the write operation is also embedded.
for i=1:size(flows,1)
    flow = flows(i,:);
    timeVector = generateFlowTime(flow,mode,param);
    flowTime = [flowTime zeros(6,size(timeVector,2))];
    flowTime{i}(1:2,:) = timeVector;
end
flowReleaseCount = zeros(1,size(flows,1));

%% Definition of the node state and data
nodeTime = [];
  
for nodeID = 1:N
    % Define the operation time for read and flush
    nodeTimeStruct = generateNodeTime(nodeID, schedule, nodeData, param);
    nodeTime = [nodeTime nodeTimeStruct];
end

%% Define the overall event time vector

overall_vector_event = schedule(2,:);

for flowID=1:size(flows,1)
    overall_vector_event = [overall_vector_event ...
                            flowTime{flowID}(2,:)];
end

for nodeID = 1:N
    overall_vector_event = [overall_vector_event ...
                            nodeTime(nodeID).CPFlushTime ...
                            nodeTime(nodeID).CPReadTime ...
                            nodeTime(nodeID).CPWriteTime ...
                            nodeTime(nodeID).APFlushTime ...
                            nodeTime(nodeID).APReadTime ...
                            ];
end

overall_vector_event = unique(overall_vector_event);


